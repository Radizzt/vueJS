<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <link rel="stylesheet" href="css/style.css" type="text/css">
</head>
<body>

<h1>Vue JS</h1>

<div id="app">
    {{message}}
</div>

<div id="app-2">
  <span v-bind:title="message">
    Hover your mouse over me for a few seconds to see my dynamically bound title!
  </span>
</div>

<div id="app-3">
    <p v-if="seen">Now you see me</p>
    <p v-else="seen">now you dont</p>
</div>

<div id="app-4">
    <ol>
        <li v-for="todo in todos">
            {{ todo.text }}
        </li>
    </ol>
</div>


<div id="app-5">
    <p>{{ message }}</p>
    <button v-on:click="reverseMessage">Reverse Message</button>
</div>

<div id="app-6">
    <p>{{ message }}</p>
    <input v-model="message">
</div>

<div id="app-7">
    <ol>
        <!-- Now we provide each todo-item with the todo object    -->
        <!-- it's representing, so that its content can be dynamic -->
        <todo-item v-for="item in groceryList" v-bind:todo="item"></todo-item>
    </ol>
</div>



<div id="apptest">
    <app-test></app-test>
</div>

<hr>
<h2>Instances and <a href="https://vuejs.org/images/lifecycle.png"> lifecycles</a></h2>
<p id="example">{{a}}</p>

<hr>
<h2>Syntax</h2>
<h3>Interpolation:</h3>

<h4>text:</h4>
<div id="syntax-1">
    <span>Message: ({{msg}}) - Change text in console 'syn1.msg' </span>
    <!--make all property static-->
    <p v-once>This message can never be change: ({{staticMsg}}) - 'syn1.staticMsg' </p>
</div>

<h4>Raw HTML:</h4>
<div id="syntax-2">
    <p>message: {{msg}}</p>
    <!--insert raw html-->
    <p v-html="rawHtml">{{rawHtml}}</p>

</div>

<h4>dynamic attribute (id)</h4>
<div class="attrib" v-bind:id="dynamicId">
    <p>{{att}}</p>
</div>

<h4>expressional data (ONLY SINGLE EXPRESSION)</h4>
<div id="syntax-3">
    <p>{{ok ? 'yes' : 'no' }}</p>
</div>
<hr>
<h3>Directive</h3>
<span class="info">Directives are special attributes with the v- prefix. Directive attribute values are expected to be a single JavaScript expression (with the exception for v-for, which will be discussed later). A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes.</span>

<div id="syntax-4">
    <p v-if="seen">Now you see me</p>
</div>

<h4>arguments</h4>
<span class="info">Some directives can take an “argument”, denoted by a colon after the directive name. For example, the v-bind directive is used to reactively update an HTML attribute:</span>
<div id="syntax-5">
    <a v-bind:href="url">Google link</a>
    <button v-on:click="doSomething">click me</button>
</div>

<h4>modifiers</h4>
<span class="info">Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the .prevent modifier tells the v-on directive to call event.preventDefault() on the triggered event:</span>
<form v-on:submit.prevent="onSubmit" id="form1">
    <input type="submit">
</form>

<h4>filter</h4>
<span class="info">Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: <span style="font-weight: bold">mustache interpolations</span> and <span style="font-weight: bold">v-bind expressions</span>. Filters should be appended to the end of the JavaScript expression, denoted by the “pipe” symbol:</span>

<div id="syntax-6">
    <div><!-- in mustaches -->
        {{ message | capitalize | lastCap | foo(' second arg', ' third arg') }}

    </div>
</div>

<h4>Shorthand:</h4>
<span class="info">The v- prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the v- prefix becomes less important when you are building an SPA where Vue.js manages every template. Therefore, Vue.js provides special shorthands for two of the most often used directives, v-bind(":") and v-on ('@')</span>

<p>v-bind:href='url'. shorthand: :href='url'</p>
<p>v-on:click='doSomething'. shorthand: @click='doSomething'</p>
<hr>

<h2>Computed Properties and Watchers</h2>
<span class="info">In-template expressions are very convenient, but they are really only meant for simple operations. Putting too much logic into your templates can make them bloated and hard to maintain.</span>


<h3>Computed Property</h3>
<div id="comp1">
    <p>Original message: "{{ message }}"</p>
    <p>Computed reversed message: "{{ reversedMessage }}"</p>
    <p>Now: {{now}}</p>
</div>

<h4>Computed Caching vs Methods</h4>
<span class="info">You may have noticed we can achieve the same result by invoking a method in the expression:</span>

<div id="comp2">
    <p>Original message: "{{ message }}"</p>
    <p>Computed reversed message: "{{ reversedMessage() }}"</p>
    <p>Now: {{now()}}</p>
</div>
<p class="info">Instead of a computed property, we can define the same function as a method instead. For the end result, the two approaches are indeed exactly the same. However, the difference is that <span class="bold">computed properties are cached based on their dependencies.</span> A computed property will only re-evaluate when some of its dependencies have changed. This means as long as message has not changed, multiple access to the reversedMessage computed property will immediately return the previously computed result without having to run the function again.<br> In comparison, a method invocation will <span class="bold">always </span>run the function whenever a re-render happens. </p>

<h4>Computed vs Watched Property</h4>
<span class="info">Vue does provide a more generic way to observe and react to data changes on a Vue instance: <span class="bold">watch properties.</span> When you have some data that needs to change based on some other data, it is tempting to overuse watch - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative watch callback.</span>

<div id="comp3">
    <p>{{ fullName }}</p>
</div>

<span class="info">vs computed version (Look into the JS file):</span>

<div id="comp4">
    <p>{{ fullName }}</p>
</div>

<h4>Computed Setter</h4>
<span class="info">Computed properties are by default getter-only, but you can also provide a setter when you need it (comp5.fullName = ''):</span>

<div id="comp5">
    <p>{{ fullName }}</p>
</div>

<h3>Watcher</h3>
<span class="info">While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That’s why Vue provides a more generic way to react to data changes through the watch option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</span>


<div id="watch1">
    <p>
        Ask a yes/no question:
        <input v-model="question">
    </p>
    <p>{{answer}}</p>
</div>











<script
        src="https://code.jquery.com/jquery-3.1.1.min.js"
        integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
        crossorigin="anonymous"></script>
<script src="https://unpkg.com/vue/dist/vue.js"></script>
<!-- Since there is already a rich ecosystem of ajax libraries    -->
<!-- and collections of general-purpose utility methods, Vue core -->
<!-- is able to remain small by not reinventing them. This also   -->
<!-- gives you the freedom to just use what you're familiar with. -->
<script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
<script src="js/core.js"></script>
<script src="js/instances.js"></script>
<script src="js/syntax.js"></script>
<script src="js/computed_properties_and_watcher.js"></script>
</body>
</html>