<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <link rel="stylesheet" href="css/style.css" type="text/css">
</head>
<body>

<h1>Vue JS</h1>

<div id="app">
    {{message}}
</div>

<div id="app-2">
  <span v-bind:title="message">
    Hover your mouse over me for a few seconds to see my dynamically bound title!
  </span>
</div>

<div id="app-3">
    <p v-if="seen">Now you see me</p>
    <p v-else="seen">now you dont</p>
</div>

<div id="app-4">
    <ol>
        <li v-for="todo in todos">
            {{ todo.text }}
        </li>
    </ol>
</div>


<div id="app-5">
    <p>{{ message }}</p>
    <button v-on:click="reverseMessage">Reverse Message</button>
</div>

<div id="app-6">
    <p>{{ message }}</p>
    <input v-model="message">
</div>

<div id="app-7">
    <ol>
        <!-- Now we provide each todo-item with the todo object    -->
        <!-- it's representing, so that its content can be dynamic -->
        <todo-item v-for="item in groceryList" v-bind:todo="item"></todo-item>
    </ol>
</div>



<div id="apptest">
    <app-test></app-test>
</div>

<hr>
<h2>Instances and <a href="https://vuejs.org/images/lifecycle.png"> lifecycles</a></h2>
<p id="example">{{a}}</p>

<hr>
<h2>Syntax</h2>
<h3>Interpolation:</h3>

<h4>text:</h4>
<div id="syntax-1">
    <span>Message: ({{msg}}) - Change text in console 'syn1.msg' </span>
    <!--make all property static-->
    <p v-once>This message can never be change: ({{staticMsg}}) - 'syn1.staticMsg' </p>
</div>

<h4>Raw HTML:</h4>
<div id="syntax-2">
    <p>message: {{msg}}</p>
    <!--insert raw html-->
    <p v-html="rawHtml">{{rawHtml}}</p>

</div>

<h4>dynamic attribute (id)</h4>
<div class="attrib" v-bind:id="dynamicId">
    <p>{{att}}</p>
</div>

<h4>expressional data (ONLY SINGLE EXPRESSION)</h4>
<div id="syntax-3">
    <p>{{ok ? 'yes' : 'no' }}</p>
</div>
<hr>
<h3>Directive</h3>
<span class="info">Directives are special attributes with the v- prefix. Directive attribute values are expected to be a single JavaScript expression (with the exception for v-for, which will be discussed later). A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes.</span>

<div id="syntax-4">
    <p v-if="seen">Now you see me</p>
</div>

<h4>arguments</h4>
<span class="info">Some directives can take an “argument”, denoted by a colon after the directive name. For example, the v-bind directive is used to reactively update an HTML attribute:</span>
<div id="syntax-5">
    <a v-bind:href="url">Google link</a>
    <button v-on:click="doSomething">click me</button>
</div>

<h4>modifiers</h4>
<span class="info">Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the .prevent modifier tells the v-on directive to call event.preventDefault() on the triggered event:</span>
<form v-on:submit.prevent="onSubmit" id="form1">
    <input type="submit">
</form>

<h4>filter</h4>
<span class="info">Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: <span style="font-weight: bold">mustache interpolations</span> and <span style="font-weight: bold">v-bind expressions</span>. Filters should be appended to the end of the JavaScript expression, denoted by the “pipe” symbol:</span>

<div id="syntax-6">
    <div><!-- in mustaches -->
        {{ message | capitalize | lastCap | foo(' second arg', ' third arg') }}

    </div>
</div>

<h4>Shorthand:</h4>
<span class="info">The v- prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the v- prefix becomes less important when you are building an SPA where Vue.js manages every template. Therefore, Vue.js provides special shorthands for two of the most often used directives, v-bind(":") and v-on ('@')</span>

<p>v-bind:href='url'. shorthand: :href='url'</p>
<p>v-on:click='doSomething'. shorthand: @click='doSomething'</p>
<hr>

<h2>Computed Properties and Watchers</h2>
<span class="info">In-template expressions are very convenient, but they are really only meant for simple operations. Putting too much logic into your templates can make them bloated and hard to maintain.</span>


<h3>Computed Property</h3>
<div id="comp1">
    <p>Original message: "{{ message }}"</p>
    <p>Computed reversed message: "{{ reversedMessage }}"</p>
    <p>Now: {{now}}</p>
</div>

<h4>Computed Caching vs Methods</h4>
<span class="info">You may have noticed we can achieve the same result by invoking a method in the expression:</span>

<div id="comp2">
    <p>Original message: "{{ message }}"</p>
    <p>Computed reversed message: "{{ reversedMessage() }}"</p>
    <p>Now: {{now()}}</p>
</div>
<p class="info">Instead of a computed property, we can define the same function as a method instead. For the end result, the two approaches are indeed exactly the same. However, the difference is that <span class="bold">computed properties are cached based on their dependencies.</span> A computed property will only re-evaluate when some of its dependencies have changed. This means as long as message has not changed, multiple access to the reversedMessage computed property will immediately return the previously computed result without having to run the function again.<br> In comparison, a method invocation will <span class="bold">always </span>run the function whenever a re-render happens. </p>

<h4>Computed vs Watched Property</h4>
<span class="info">Vue does provide a more generic way to observe and react to data changes on a Vue instance: <span class="bold">watch properties.</span> When you have some data that needs to change based on some other data, it is tempting to overuse watch - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative watch callback.</span>

<div id="comp3">
    <p>{{ fullName }}</p>
</div>

<span class="info">vs computed version (Look into the JS file):</span>

<div id="comp4">
    <p>{{ fullName }}</p>
</div>

<h4>Computed Setter</h4>
<span class="info">Computed properties are by default getter-only, but you can also provide a setter when you need it (comp5.fullName = ''):</span>

<div id="comp5">
    <p>{{ fullName }}</p>
</div>

<h3>Watcher</h3>
<span class="info">While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That’s why Vue provides a more generic way to react to data changes through the watch option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</span>


<div id="watch1">
    <p>
        Ask a yes/no question:
        <input v-model="question">
    </p>
    <p>{{answer}}</p>
</div>

<hr>

<h2>Class and Style Binding</h2>
<span class="info">A common need for data binding is manipulating an element’s class list and its inline styles. Since they are both attributes, we can use v-bind to handle them: we just need to calculate a final string with our expressions. However, meddling with string concatenation is annoying and error-prone. For this reason, Vue provides special enhancements when v-bind is used with class and style. In addition to strings, the expressions can also evaluate to objects or arrays.</span>

<h3>Binding HTML Classes</h3>

<h4>Object Syntax</h4>
<span class="info">We can pass an object to v-bind:class to dynamically toggle classes:</span>

<div id="class1">
    <!--inline-->
    <div class="staticClass" v-bind:class="{active: isActive, 'text-danger': hasError }">
        <p>{{message}}</p>
    </div>
    <!--external-->
    <div class="staticClass" v-bind:class="classObject">
        <p>{{message}}</p>
    </div>
    <!--computed property-->
    <div class="staticClass" v-bind:class="computedObject">
        <p>{{message}}</p>
    </div>
</div>

<h4>Array Syntax</h4>
<span class="info">We can pass an array to v-bind:class to apply a list of classes:</span>

<div id="class2">
    <div v-bind:class="[activeClass, errorClass]">
        <p>{{message}}</p>
    </div>
    <!--ternary expression to toggle-->
    <div  v-bind:class="[isActive ? activeClass : errorClass]">
        <p>{{message}}</p>
    </div>
    <!--object syntax within an array syntax-->
    <div  v-bind:class="[{activeClass : isActive}, errorClass]">
        <p>{{message}}</p>
    </div>
</div>

<h3>Binding Inline Styles</h3>
<h4>Object Syntax</h4>
<span class="info">The object syntax for v-bind:style is pretty straightforward - it looks almost like CSS, except it’s a JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:</span>

<div id="bind1">
    <!--inline style (Change fontsize with bind1['fontSize'] = 33-->
    <div v-bind:style="{color: activeColor, fontSize: fontSize + 'px'}">
        <p>inline style</p>
    </div>
    <!--style object-->
    <div v-bind:style="styleObject">
        <p>Style Object</p>
    </div>
    <!--array Syntax -->
    <div v-bind:style="[baseStyles, overridingStyles]">
        <p>Array Style</p>
    </div>
    <h5>auto-prefixing</h5>
    <span class="info">When you use a CSS property that requires vendor prefixes in v-bind:style, for example transform, Vue will automatically detect and add appropriate prefixes to the applied styles.</span>
    <!--Transform -->
    <div v-bind:style="transformObject">
        <p>Array Style</p>
    </div>
</div>
<hr>
<h2>Conditional Rendering</h2>
<h3>v-if</h3>
<div id="if1">
    <span class="info">refresh window to retrigger the Math.random method</span>
    <div v-if="Math.random() > 0.5">
        <p>true</p>
    </div>
    <div v-else>
        <p>false</p>
    </div>
    <!--Conditional Groups with v-if on <template>-->
    <template v-if="ok">
        <h1>title</h1>
        <p>para1</p>
        <p>para2</p>
    </template>

    <!--v-else-if conditioning-->
    <div v-if="type === 'A'">
        <p>A</p>
    </div>
    <div v-else-if="type === 'B'">
        <p>B</p>
    </div>
    <div v-else-if="type === 'C'">
        <p>C</p>
    </div>
    <div v-else>
        <p>Not A/B/C</p>
    </div>

</div>

<h3>Controlling Reusuable Elements with key</h3>

<span class="info">Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:</span>

<div id="if2">

    <template v-if="loginType === 'username'">
        <label>Username</label>
        <input placeholder="Enter your username">
    </template>
    <template v-else>
        <label>Email</label>
        <input placeholder="Enter your email address">
    </template>
    <button v-on:click="toggle">Toggle login type</button>
    <br>
    <br />

    <p>if this is not the desire effect you want, use <span class="bold">key attribute:</span></p>
    <template v-if="loginType2 === 'username'">
        <label>Username</label>
        <input placeholder="Enter your username" key="username-input">
    </template>
    <template v-else>
        <label>Email</label>
        <input placeholder="Enter your email address" key="email-input">
    </template>
    <button v-on:click="toggle2">Toggle login type</button>

</div>

<h3>v-show</h3>
<span class="info">
    Another option for conditionally displaying an element is the v-show directive. <br>
    The difference is that an element with v-show will always be rendered and remain in the DOM; v-show simply toggles the display CSS property of the element. <br>
    ** Note that v-show doesn’t support the &lt;template&gt; syntax, nor does it work with v-else.
</span>
<div id="show1">
    <button v-on:click="toggle">toggle</button>
    <p v-show="ok">showing</p>
</div>
<span class="info">Generally speaking, v-if has higher toggle costs while v-show has higher initial render costs. So prefer v-show if you need to toggle something very often, and prefer v-if if the condition is unlikely to change at runtime.</span>

<hr>
<h2>List Rendering</h2>
<h3>v-for</h3>
<span class="info">
    We can use the v-for directive to render a list of items based on an array. The v-for directive requires a special syntax in the form of item in items, where items is the source data array and item is an alias for the array element being iterated on:
</span>
<h3>key</h3>
<span class="info">When Vue is updating a list of elements rendered with v-for, it by default uses an “in-place patch” strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will simply patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of track-by="$index" in Vue 1.x.
This default mode is efficient, but only suitable <span class="bold">when your list render output does not rely on child component state or temporary DOM state (e.g. form input values).</span>
To give Vue a hint so that it can track each node’s identity, and thus reuse and reorder existing elements, you need to provide a unique key attribute for each item. An ideal value for key would be the unique id of each item. This special attribute is a rough equivalent to track-by in 1.x, but it works like an attribute, so you need to use v-bind to bind it to dynamic values </span>
<ul id="for1">
    <li v-for="item in items" :key="item.id">
        {{ item.message}}
    </li>
    <!--support second argument for index number-->
    <h4>index</h4>
    <p class="info">Inside v-for blocks we have full access to parent scope properties. v-for also supports an optional second argument for the index of the current item.</p>
    <li v-for="(item, index) in items2">
        {{ parentMessage }} - {{index}} - {{ item.message}}
    </li>
    <!--template for v-for-->
    <h4>template v-for</h4>
    <p class="info">Similar to template v-if, you can also use a &lt;template&gt; tag with v-for to render a block of multiple elements. For example:</p>
    <template v-for="item in forItem">
        <li>{{item.msg}}</li>
    </template>
    <!--object v-for-->
    <h4>object v-for</h4>
    <p class="info">You can also use v-for to iterate through the properties of an object.</p>
    <li v-for="value in object">
        {{value}}
    </li>
    <!--key and index for object-->
    <h4>key and object for object</h4>
    <p class="info">You can also provide a second argument for the key, and another for index</p>
    <li v-for="(value, key, index) in object">
        {{index}}. {{key}} : {{value}}
    </li>
    <!--range-->
    <h4>Range v-for</h4>
    <p class="info">v-for can also take an integer. In this case it will repeat the template that many times.
    <li>
        <span v-for="n in 10">{{ n }}</span>
    </li>
    <h4>v-for with v-if</h4>
    <p class="info">When they exists on the same node, v-for has a higher priority than v-if. That means the v-if will be run on each iteration of the loop separately. This is very useful when you want to render nodes for only some items, like below:</p>
    <li v-for="todo in todos" v-if="!todo.isComplete">
        {{ todo.duty }}
    </li>


</ul>

<!--component and v-for-->
<h4>Component and v-for</h4>
<p class="info">You can directly use v-for on a custom component, like any normal element:</p>
<div id="todo-list-example">
    <input
            v-model="newTodoText"
            v-on:keyup.enter="addNewTodo"
            placeholder="Add a todo"
    >
    <ul>
        <li
                is="todo-item"
                v-for="(todo, index) in todos"
                v-bind:title="todo"
                v-on:remove="todos.splice(index, 1)"
        ></li>
    </ul>
</div>

<h3>Array Change Detection</h3>

<h4>Mutation Methods</h4>
<div class="info">
    <p>Vue wraps an observed array’s mutation methods so they will also trigger view updates. The wrapped methods are:</p>
    <ul>
        <li>push()</li>
        <li>pop()</li>
        <li>shift()</li>
        <li>unshift()</li>
        <li>splice()</li>
        <li>sort()</li>
        <li>reverse()</li>
    </ul>
    <p>You can open the console and play with the previous examples’ items array by calling their mutation methods. For example: example1.items.push({ message: 'Baz' }).</p>
</div>
<h4>Replacing an Array</h4>
<p class="info">Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. filter(), concat() and slice(), which do not mutate the original Array but always return a new array.</p>

<ul id="for2">
    <button @click="replace">replace!</button>
    <li v-for="item in items">
        {{item.message}}
    </li>

    <h3>Displaying Filtered/Sorted Result</h3>
    <p class="info">Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.</p>
    <li v-for="n in evenNumbers">{{n}}</li>
    <p class="info">method version:</p>
    <li v-for="n in even(numbers)">{{n}}</li>
</ul>







<script
        src="https://code.jquery.com/jquery-3.1.1.min.js"
        integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
        crossorigin="anonymous"></script>
<script src="https://unpkg.com/vue/dist/vue.js"></script>
<!-- Since there is already a rich ecosystem of ajax libraries    -->
<!-- and collections of general-purpose utility methods, Vue core -->
<!-- is able to remain small by not reinventing them. This also   -->
<!-- gives you the freedom to just use what you're familiar with. -->
<script src="https://unpkg.com/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://unpkg.com/lodash@4.13.1/lodash.min.js"></script>
<script src="js/core.js"></script>
<script src="js/instances.js"></script>
<script src="js/syntax.js"></script>
<script src="js/computed_properties_and_watcher.js"></script>
<script src="js/class_style_binding.js"></script>
<script src="js/conditional_rendering.js"></script>
<script src="js/list_rendering.js"></script>
</body>
</html>